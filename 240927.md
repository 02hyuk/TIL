# 디자인 패턴 소개와 전략 패턴
## 문제 상황
오리 시뮬레이션 게임 회사 내의 이야기

게임의 아키텍처는 아래와 같음
* Duck
    * 모든 오리는 꽥꽥거리고 수영할 수 있으므로 quack(), swim() 정의
    * 모든 오리의 모양이 다르므로 추상 메서드 display()
    * 서브 클래스: MallardDuck, RedheadDuck, RubberDuck 등

Duck 클래스를 상속하는 다양한 오리 클래스에 날아다니는 기능을 추가해야 하는 상황

### 해결하기 위한 여러 시도
1. Duck 클래스에 fly() 메서드 정의 및 구현
    * 날지 못하는 오리(RubberDuck 등)에게는 부적합한 메서드인 fly()가 상속됨
2. 1과 달리 Duck에서 fly 정의, 서브 클래스에서 fly 구현
    * 서브 클래스에서 fly 구현시 중복되는 코드 발생
    * 날아다니는 기능에 변경이 생길 때마다 fly() 구현을 여러 서브 클래스에서 수정해줘야 함
3. 날아다니는 기능이 필요한 오리만 Flyable 인터페이스 구현
    * MallardDuck 등의 클래스만 Flyable을 구현하면 됨(RubberDuck은 관계X)
    * 코드 재사용을 고려하지 못한 방법

## 소프트웨어 디자인 원칙
0. 소프트웨어는 개발의 모든 과정에서 언제나 **변화**할 수 있음
1. 애플리케이션에서 **달라지는 부분**을 찾아내고, 달라지지 않는 부분과 **분리**하기
    * 바뀌는 부분을 분리해 캡슐화하면 바뀌지 않는 부분에는 영향을 미치지 않고 해당 부분만 고치거나 확장 가능
    * 즉, 의도치 않은 버그를 줄이면서 시스템의 유연성 향상 가능
2. 구현보다는 **인터페이스**에 맞춰서 프로그래밍하기
    * 상위 형식에 맞춰 프로그래밍한다는 의미에 더 가까움
    * 변수 선언시 상위 형식으로 선언하면 어떤 객체든 넣을 수 있고, 변수에 할당하는 실제 객체가 무엇인지 몰라도 됨
3. 상속보다는 **구성(composition)** 활용하기

## 문제 해결 방법
### 1. 시스템 내에서 바뀌는 부분을 분리
나는 것과 관련된 부분
* 날 수 있는 오리와 아닌 오리 존재

꽥꽥거리는 것과 관련된 부분
* RubberDuck은 꽥꽥 대신 삑삑 하고 소리냄
* 해결할 문제는 날아다니는 기능을 추가하는 것이었지만, 꽥꽥거리는 기능도 비슷한 방식으로 리팩토링할 수 있으므로 같이 분리

-> Duck 클래스로부터 quack(), fly()를 분리

### 2. 각 행동을 나타낼 클래스 집합 정의
변화하는 부분과 그대로인 부분을 분리하기 위해 클래스 집합을 아래처럼 정의
* 나는 행동: 날아다니기, 날지 못함
* 꽥꽥거리기: 진짜로 꽥꽥거리기, 삑삑 소리 내기, 소리내지 못함

### 3. 오리의 행동 디자인
오리의 행동에 관한 클래스 집합을 디자인할 때 고려할 요소
* 코드 변경에 대한 유연성
* 오리의 행동을 동적으로 할당 가능

각 행동(behavior)을 인터페이스로 표현하고 행동 클래스가 구현하는 식으로 클래스 집합을 디자인
* FlyBehavior: fly() 정의
    * FlyWithWings, FlyNoWay 등의 클래스에서 인터페이스 구현
    * FlyWithWings는 진짜로 날아다니도록, FlyNoWay는 날지 못하게 fly 구현
* QuackBehavior: quack() 정의
    * Quack, Squeak, MuteQuack 등의 클래스도 위의 방식대로 quack 구현

이처럼 변화하는 부분(오리의 행동)을 클래스 집합으로 정의하면, 변화하지 않는 측(Duck)이 인터페이스를 통해 이미 구현된 클래스(행동)을 사용하기만 하면 됨
* Duck이 구현할 필요가 없음

### 4. 오리의 행동 통합
1. Duck에서 분리한 행동 부분을 다시 통합하기 위해 Duck에 FlyBehavior, QuackBehavior 타입의 필드를 추가
    * Duck의 행동을 처리하기 위해 변화하는 부분을 필드로서 사용해야 함
2. 필드에 기능을 위임하기 위해 Duck에 performFly(), performQuack() 추가 후, 내부에서 필드가 이름에 맞는 행동을 대신 수행하도록 메서드 구현
    * 필드에 할당된 객체의 종류가 무엇이든 상관 없이 기능 수행 가능
3. 이후 서브 클래스에서 필드에 적절한 행동 구현체를 매핑
    * 객체를 매핑하기 위해 서브 클래스의 생성자, 세터 메서드 등을 정의

```java
// Duck에서 꽥꽥거리는 행동을 위임하고, MallardDuck에서 행동의 객체를 매핑하는 모습
public abstract class Duck {
    QuackBehavior quackBehavior;
    FlyBehavior flyBehavior;

    public void performQuack() {
        quackBehavior.quack();
    }
    public void performFly() {
        flyBehavior.fly();
    }

    // 그 외 코드
}

// 청둥오리는 꽥꽥거리고 날개로 날아야 하므로 아래와 같이 정의
public class MallardDuck extends Duck {
    public MallardDuck() {
        quackBehavior = new Quack();
        flyBehavior = new FlyWithWings();
    }

    // 그 외 코드
}
```

## 전략 패턴
### 구성(composition)
'A에는 B가 있다' 관계처럼 한 클래스가 다른 클래스를 포함하는 것

A의 행동을 수행하기 위해 B가 그 역할을 위임받을 수 있음
* 오리의 행동을 수행하기 위해 행동 인터페이스와 그 구현체를 이용했던 모습 기억

구성을 활용해 시스템을 만들면 유연성 대폭 향상 가능

단순히 알고리즘군을 별도의 클래스 집합으로 캡슐화할 수도 있고, 구성 요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면 실행시에 행동을 동적으로 변경 가능

구성은 여러 디자인 패턴에서 쓰이므로 구성의 장단점을 잘 알아야 함

### 전략 패턴(Strategy Pattern)
**알고리즘군을 정의하고 캡슐화**해서 각각의 알고리즘군을 수정해서 사용할 수 있게 하는 패턴

전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경 가능

## 디자인 패턴에 대한 이야기
### 디자인 패턴 사용의 장점
* 개발자 사이에서 서로 이해할 수 있는 용어를 제공
    * 패턴으로 의사소통시 패턴 이름과 패턴의 모든 내용, 특성, 제약조건 등을 이야기할 수 있음
* 간단한 단어로 많은 정보 전달 가능
* 오해의 소지 감소로 인한 개발/협업 능력 극대화
* 패턴 수준에서 생각하게 되어 아키텍처 설계 수준 향상
### 디자인 패턴의 용도
라이브러리와 프레임워크의 API를 이용하기만 하면 복잡한 기능을 간편하게 사용 가능
* 하지만 애플리케이션의 구조를 유연하게 만드는 것에는 도움을 주지 못함
* 애플리케이션의 구조를 최적화하는데 쓰이는 것이 디자인 패턴

디자인 패턴 자체가 코드에 바로 적용되지는 않음
* 코드의 상태를 보고 문제점을 파악한 뒤, 패턴을 통해 변경에 유연한 코드로 개선하는 식으로 작동

### 객체지향과 디자인 패턴의 관계
재사용이 용이하고 관리하기 쉬운 객체지향 시스템을 구축하는 일은 쉽지 않음
* 캡슐화, 추상화, 다형성 등만 안다고 쉽게 해결할 수 있는 문제가 아님

수많은 사람들이 고민하여 찾아낸 객체지향 시스템 구축에 필요한 방법들이 디자인 패턴임